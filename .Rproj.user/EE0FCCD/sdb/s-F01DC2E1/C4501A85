{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Applied SFC modelling with R\"\nauthor: \"Antoine Godin\"\ndate: \"03 August 2016\"\noutput: slidy_presentation\nruntime: shiny\nbibliography: Bibliography.bib\n---\n\n```{r,echo=F,include=FALSE}\nlibrary(plotrix)\nlibrary(pdfetch)\nlibrary(networkD3)\nlibrary(knitr)\n```\n\n\n## Outline\n> All the code can be found here: [http://github.com/antoinegodin/AppliedSFC_R](http://github.com/antoinegodin/AppliedSFC_R)\n\n- pdfetch\n- PKSFC package\n- SFC visualisation\n  * Direct Acyclical Graphs\n  * Sankey diagrams\n  * Shiny Applications\n- Calibration procedures\n  * Theoretical steady/stationary states\n  * Empirical calibration\n- Bank of England Model\n\n## pdfecth\n\n- Fetch Economic and Financial Time Series Data from Public Sources\n- Package developped by Abiel Reinhart\n- We will be using the `pdfetch_EUROSTAT` function\n\n```{r,eval=FALSE}\n?pdfetch_EUROSTAT\n```\n\n## Example 1: Net lending per sector, UK\n\n```{r,message=FALSE}\n\n# Specifying the name of the flows of interests\nnames<-c(\"B9\")\n\n# Downloading the data by specifying the various filters\nUKdata_raw = pdfetch_EUROSTAT(flowRef = \"nasa_10_nf_tr\", UNIT=\"CP_MNAC\",NA_ITEM=names, GEO=\"UK\", \n                              DIRECT=\"PAID\",SECTOR=c(\"S11\",\"S12\",\"S13\",\"S14_S15\",\"S2\"))\n\n# Transforming the obtained data into a data.frame\nUKdata<-as.data.frame(UKdata_raw)\n\n# Setting readable names\ncolnames(UKdata)<-c(\"NFC\",\"FC\",\"Govt\",\"HH\",\"RoW\")\n\n# Matricial plot\nmatplot(1995:2015,UKdata,lwd=2,type=\"l\",lty=1,ylab=\"\",xlab=\"\",col=2:6)\n\n# Adding the horizontal line\nabline(h=0,col=1)\n\n# Adding a grid\ngrid()\n\n# Adding a legend\nlegend(\"bottomleft\",col=c(2:6),lwd=2,lty=1,legend=c(\"NFC\",\"FC\",\"Govt\",\"HH\",\"RoW\"),bty='n')\n```\n\n## Example 2: Household income statement from 2014\n\n```{r,message=FALSE}\n\n# Selecting the flows\nnames<-c(\"B5G\",\"D5\",\"D61\",\"D62\",\"D7\",\"D8\",\"B6G\",\"P3\",\"B8G\",\"P5G\",\"D9\",\"NP\",\"B9\")\n\n# Obtaining the data\nEZdata_raw = pdfetch_EUROSTAT(\"nasa_10_nf_tr\", UNIT=\"CP_MNAC\",NA_ITEM=names, GEO=\"EU28\",\n                              SECTOR=c(\"S14_S15\"), TIME=\"2014\")\n\n# Transforming the data into a data.frame\nEZdata<-as.data.frame(EZdata_raw)\n\n# Automatic procedure to remove the non-interesting bit of the colnames\ncoln<-colnames(EZdata)\nnewcoln<-c()\nHHdata<-c()\n\nfor(i in 1:length(coln)){\n  name<-coln[i]\n  tname<-strsplit(name,\"\\\\.\")[[1]]\n  newname<-paste(tname[3:4],collapse=\".\")\n  # If the column contains only NA, remove it from the dataset\n  if(!is.na(EZdata[16,i])){\n    newcoln<-c(newcoln,newname) \n    HHdata<-c(HHdata,EZdata[16,i])\n  }\n}\n\n# Creating a new dataset with only values 2014\nHHdata<-as.data.frame(t(HHdata))\ncolnames(HHdata)<-newcoln\n\n# Creating the aggregates\nHHdata_1<-as.data.frame(c(HHdata$PAID.B5G,-HHdata$PAID.D5,-HHdata$PAID.D61+HHdata$RECV.D61,\n                          +HHdata$RECV.D62-HHdata$PAID.D62,-HHdata$PAID.D7+HHdata$RECV.D7,HHdata$PAID.B6G))\ncolnames(HHdata_1)<-\"2014\"\nrownames(HHdata_1)<-c(\"Total Income\",\"Taxes\",\"Social Contributions\",\"Social Benefits\",\n                      \"Other transfers\",\"Gross Disposable Income\")\nkable(HHdata_1)\n\nHHdata_2<-as.data.frame(c(HHdata$PAID.B6G,-HHdata$PAID.P3,-HHdata$PAID.D8+HHdata$RECV.D8,\n                          HHdata$PAID.B8G))\ncolnames(HHdata_2)<-\"2014\"\nrownames(HHdata_2)<-c(\"Gross Disposable Income\",\"Consumption\",\"Adjustments in Pensions\",\n                      \"Gross Savings\")\nkable(HHdata_2)\n\nHHdata_3<-as.data.frame(c(HHdata$PAID.B8G,-HHdata$PAID.P5G,-HHdata$PAID.D9+HHdata$RECV.D9,\n                          -HHdata$PAID.NP,HHdata$PAID.B9))\n\ncolnames(HHdata_3)<-\"2014\"\nrownames(HHdata_3)<-c(\"Gross Savings\",\"Gross Capital Formation\",\"Capital Transfer\",\n                      \"Net Non-Produced NF Assets\",\"Net Lending Position\")\nkable(HHdata_3)\n```\n\n## PKSFC package\n\n- Allowing to simulate SFC models in an open source environment}\n* Still preliminary\n* Only one numerical solver: Gauss-Seidel algorithm (Kinsella and O'Shea 2010)\n* github.com/s120/pksfc\n- Technical aspect\n* R package\n* EViews translator\n* Read equation files\n* Build model from console\n* Visualisation/Design tools and helpers\n\n## Installing the dependent libraries and the package\nYou need to install all the required libraries This is for traditional libraries\n```{r, eval=F}\ninstall.packages(\"expm\")\ninstall.packages(\"igraph\")\n```\n\nFor non-conventional libraries, such as the one need to visualize Direct Acyclical Graphs (DAG), you need to do the following\n```{r,eval=F}\nsource(\"http://bioconductor.org/biocLite.R\")\nbiocLite(\"Rgraphviz\")\n```\n\nFinally you can then download the PKSFC package from github and install it locally\n```{r, eval=F}\ninstall.packages(\"path/PKSFC_1.5.tar.gz\", repos = NULL, type=\"source\")\n```\n\n\n## Testing\nNow we're ready to load the package:\n```{r}\nlibrary(PKSFC)\n```\n\n1. Load SIM (download SIM.txt from Github)\n```{r}\nsim<-sfc.model(\"SIM.txt\",modelName=\"SIMplest model from chapter 3 of Godley and Lavoie (2007)\")\n```\n2. Simulate the model\n```{r}\ndatasim<-simulate(sim)\n```\n3. replicate figure 3.2 of page 73.\n```{r, width=10}\nplot(sim$time,datasim$baseline[,\"Yd\"],type=\"l\", xlab=\"\", ylab=\"\", lty=2, \n     ylim=range(datasim$baseline[,c(\"Yd\",\"C\")],na.rm=T))\nlines(sim$time,datasim$baseline[,\"C\"],lty=3)\nlines(sim$time,vector(length=length(sim$time))+datasim$baseline[\"2010\",\"C\"])\nlegend(x=1970,y=50,legend=c(\"Disposable Income\",\"Consumption\",\"Steady State\"),lty=c(2,3,1),bty=\"n\")\n``` \n\n## How does it work?\n\n- The package parses a text file containing the equations\n- It generates an internal representation of the model\n- It checks the internal consistency of the model, the calibration\n- Allows to simulate the model using a linear solver, the Gauss-Seidel Algorithm\n\n## Source code of SIM\n\n```{r, eval=FALSE}\n#1. EQUATIONS\nC = C\nG = G\nT = T\nN = N\nYd = W*N - T\nT = theta*W*N\nC = alpha1*Yd + alpha2*H_h(-1)\nH = H(-1) + G - T\nH_h = H_h(-1) + Yd - C\nY = C + G\nN = Y/W\n#2. PARAMETERS\nalpha1=0.6\nalpha2=0.4\ntheta=0.2\n#EXOGENOUS\nG=20\nW=1\n#INITIAL VALUES\nH=0\nH_h=0\n#3. Timeline\ntimeline 1945 2010\n```\n\n\n## A few important points regarding the model source code:\n- The first line of the code should be a comment line (starting with `#`)\n- The file should not contain any empty lines.\n- You should avoid naming your variables with reserved names in R such as 'in' or 'max'.\n- There should be only one equation per line.\n- There should be only one variable on the left hand side of the equation.\n- You can use R functions such as min, max, or logical operators such as > or <=. In the case the logical operatur returns true, the numeric value will be one. Thus `(100>10)` will return `1`.\n- The lag operator is represented by `(-x)` where `x` is the lag.\n- You can add as many comments, using the `#` character at the begining of the line. Each comment exactly above an equation will be considered as the description of the equation and will be stored in the internal representation of the sfc model object.\n\n## Internal representation\n\n```{r}\nprint(sim)\n```\n\n## Output data structure\n- Output is a list of matrix where each element of the list are a scenario\n* baseline\n* scenario_i\n\n```{r}\nkable(datasim$baseline)\n```\n\n## The Gauss Seidel Algorithm\n\n- Principle:\nSolving $Ax=b,\\, A\\in\\mathbb{R}^{n\\times n},\\, b\\in \\mathbb{R}^n$ via an iterative algorithm, where each iteration can be represented by $L x^{k+1} = b-Ux^{k},\\, A=L+U$. Where $L$ is lower triangular and $U$ is upper triangular. \n\n- Pseudo-code:\n1. Select initial values $x^0$\n2. While $k<maxIter$ \\& $\\delta < tolValue$\na. For each $i=1,...,n$: $$x_i^{k+1}=\\frac{1}{a_{ii}}\\left( b_i-\\sum^{i-1}_{j=1}a_{ij} x_j^{k+1}-\\sum_{j=i+1}^n a_{ij}x_j^k\\right)$$\nb. Compute $\\delta$: $$\\delta = \\frac{x^{k+1}-x^k}{x^k}$$\n\n## System of (in)dependent equations\n> See Fenell et. al (2016) \n\n- The Gauss-Seidel has to be used only in the case of system of dependent equations\n- In other case, we only need to find order in which each variable is computed and simply compute the new value in each period\n- This order is the \"logical causal order\" of the model and can be visualised using Direct (A)Cyclical Graphs \n\n## Direct Acyclic graphs\n\n```{r}\nsimex<-sfc.model(\"SIMEX.txt\",modelName=\"SIMplest model with expectation\")\nlayout(matrix(c(1,2),1,2))\nplot.dag(sim,main=\"SIM\" )\nplot.dag(simex,main=\"SIMEX\" )\n```\n\n- Aside from the mathematical implication that a system of equation represent, it also has an economic meaning:\n* the economy represented by SIM will adjust in one period to any shock applied to government spending. \n* for SIMEX it is not the case because consumption depend on expected disposable income which is equal to previous period disposable income. \n* in this case, the economy represented by SIMEX will adjust slowly to a shock applied to government spending, via the stocks (and particularly the buffer stock)\n\n## In the case of a more complex model - Chapter 6\n\n- We can generate the plots that allow us to delve into the actual structure of the system.\n- Nodes that do not form a cycle are green while nodes that form a cycle in the system are pink.\n- The Gauss-Seidel needs to be applied only for the cycles\n\n````{r}\nch6 <- sfc.model(\"ch6.txt\",modelName=\"Chapter6_openmodel\")\ngraphs = generate.DAG.collapse( adjacency = ch6$matrix )\npar(mfrow = c(1,3))\n# first plot the orgianl grpah\nplot_graph_hierarchy( graphs$orginal_graph, main = \"orginal graph\" )\n# plot hte nodes that form the strongly connected compoent\nplot_graph_hierarchy( graphs$SCC_graph, main = \"SCC nodes\" )\n# plot the result ing DAG when we take the condensation of the graph\nplot_graph_hierarchy( graphs$DAG, main = \"resulting DAG\" )\n````\n\n\n\n## Systems of dependent vs independent equations \n\n```{r}\ndatasimex<-simulate(simex)\ninit = datasimex$baseline[66,]\nsimex<-sfc.addScenario(simex,\"G\",25,1960,2010,init)\ndatasimex<-simulate(simex)\ndatasim<-simulate(sim)\ninit = datasim$baseline[66,]\nsim<-sfc.addScenario(sim,\"G\",25,1960,2010,init)\ndatasim<-simulate(sim)\nplot(sim$time,datasim$scenario_1[,\"H\"],type=\"l\",xlab=\"\",ylab=\"\",main=\"SIM\")\nlines(sim$time,datasim$scenario_1[,\"C\"],lty=2)\nlines(sim$time,datasim$scenario_1[,\"Yd\"],lty=3)\nlegend(x=1944,y=130,legend=c(\"Wealth\",\"Consumption\",\"Disposable Income\"),\n       lty=c(1,2,3),bty=\"n\")\nplot(simex$time,datasimex$scenario_1[,\"H\"],type=\"l\",xlab=\"\",ylab=\"\",main=\"SIMEX\")\nlines(simex$time,datasimex$scenario_1[,\"C\"],lty=2)\nlines(simex$time,datasimex$scenario_1[,\"Yd\"],lty=3)\nlines(simex$time,datasimex$scenario_1[,\"Yd_e\"],lty=4)\nlegend(x=1944,y=130,legend=c(\"Wealth\",\"Consumption\",\"Disposable Income\",\n                             \"Expecetd Disposable Income\"),lty=c(1,2,3,4),bty=\"n\")\n```\n\n## Computational implications\n\nLet's see how much time it takes to run sim:\n```{r}\nptm <- proc.time()\ndata1<-simulate(sim)\nprint(paste(\"Elapsed time is \",proc.time()[3]-ptm[3],\"seconds\"))\n```\n\nNow lets play with some of the parameters of the simulate function:\n\n1. tolValue\n```{r}\nptm <- proc.time()\ndata2<-simulate(sim,tolValue = 1e-3)\nprint(paste(\"Elapsed time is \",proc.time()[3]-ptm[3],\"seconds\"))\n```\n2. maxIter\n```{r}\nptm <- proc.time()\ndata3<-simulate(sim, maxIter=10)\nprint(paste(\"Elapsed time is \",proc.time()[3]-ptm[3],\"seconds\"))\n```\n\n## Observing the results of the three simulations\n```{r}\nkable(round(t(data1$baseline[c(1,2,20,40,66),c(\"G\",\"Y\",\"T\",\"Yd\",\"C\",\"H\",\"H_h\")]),digits=3))\nkable(round(t(data2$baseline[c(1,2,20,40,66),c(\"G\",\"Y\",\"T\",\"Yd\",\"C\",\"H\",\"H_h\")]),digits=3))\nkable(round(t(data3$baseline[c(1,2,20,40,66),c(\"G\",\"Y\",\"T\",\"Yd\",\"C\",\"H\",\"H_h\")]),digits=3))\n```\n\n## Block Gauss-Seidel\nThe order of equations matters, if first compute variables that do not depend on current period, this speeds the process. Define blocks of equation independent from the others.\n```{r}\nprint(simex)\n```\n\n\n## Simulation of SIMEX\n```{r}\nptm <- proc.time()\ndataex<-simulate(simex,tolValue = 1e-10)\nprint(paste(\"Elapsed time is \",proc.time()[3]-ptm[3],\"seconds\"))\n```\n\n\n## Results for SIMEX\n```{r}\nkable(round(t(dataex$baseline[c(1,2,20,40,66),c(\"G\",\"Y\",\"T\",\"Yd\",\"Yd_e\",\"C\",\"H\",\"H_h\")]),digits=3))\n```\n\n## Output data structure\n- Output is a list of matrix where each element of the list are a scenario\n* baseline\n* scenario_i\n- In the result matrix, there is a column indicating the number of iteration in the Gauss-Seidel algorithm per block of equations per period\n\n```{r}\nkable(dataex$baseline)\n```\n\n## Checking the number of iteractions\n\n- For sim, no simulate parameters:\n```{r}\nkable(round(t(data1$baseline[c(1,2,20,40,66),c(\"iter block 1\")]),digits=3))\n```\n- For sim, tolValue fixed:\n```{r}\nkable(round(t(data2$baseline[c(1,2,20,40,66),c(\"iter block 1\")]),digits=3))\n```\n- For sim, maxIter fixed:\n```{r}\nkable(round(t(data2$baseline[c(1,2,20,40,66),c(\"iter block 1\")]),digits=3))\n```\n- For simex, no simulate parameters\n```{r}\nkable(round(t(dataex$baseline[c(1,2,20,40,66),c(\"iter block 1\",\"iter block 2\",\"iter block 3\",\"iter block 4\",\"iter block 5\",\"iter block 6\",\"iter block 7\")]),digits=3))\n```\n\n## Buffer stocks, using model PC\n\n- Observe the buffer role of money, in case of random shocks applied to expected disposable income\n- we need to modify slightly model pc and change the equations determining \n* consumption, \n* demand for bonds and money, \n* expectations on income and wealth\n\n```{r}\npc<-sfc.model(\"PC.txt\",modelName=\"Portfolio Choice Model\")\n# Changing Existing equations\npcRand<-sfc.editEqus(pc,list(\n  list(var=\"cons\",eq=\"alpha1*yde+alpha2*v(-1)\"),\n  list(var=\"b_h\",eq=\"ve*(lambda0 + lambda1*r - lambda2*(yde/ve))\")))\n\n# Adding equations\npcRand<-sfc.addEqus(pcRand,list(\n  list(var=\"yde\",eq=\"yd(-1)*(1+rnorm(1,sd=0.1))\",desc=\"Expected disposable income depending on random shocks\"),\n  list(var=\"h_d\",eq=\"ve-b_h\",desc=\"Money demand\"),\n  list(var=\"ve\",eq=\"v(-1)+yde-cons\",desc=\"Expected disposable income\")))\n\n# Adding the initial value of yd (to be used in the expectation function)\npcRand<-sfc.editVar(pcRand,var=\"yd\",init=86.48648)\n\n# Checking if the model is complete\npcRand<-sfc.check(pcRand)\n```\n\n- Before simulatin the model, let's have a look at how the graph of the model has changed:\n```{r}\nplot.dag(pcRand,main=\"PC Random\" )\n```\n\n```{r}\ndatapcRand<-simulate(pcRand,maxIter=2)\nplot(pcRand$time,datapcRand$baseline[,\"h_h\"],type=\"l\",xlab=\"\",ylab=\"\",lty=1,lwd=2,\n     ylim=c(1*min(datapcRand$baseline[,c(\"h_h\",\"h_d\")],na.rm=T),\n            1.2*max(datapcRand$baseline[,c(\"h_h\",\"h_d\")],na.rm=T)))\nlines(pcRand$time,datapcRand$baseline[,\"h_d\"],lty=2,lwd=2)\nlegend(x=1950,y=1.2*max(datapcRand$baseline[,c(\"h_h\",\"h_d\")],na.rm=T),\n       legend=c(\"Money held\",\"Money demand\"),lty=c(2,1),lwd=2,bty=\"n\")\n```\n\n- This graph highlights the buffer role of certain stocks in PK-SFC models.\n* expectations are incorrect \n* demand might not be equal to supply in any market\n- one stock will not be equal to the targeted level, as highlighted by @Foley:1975, in a model without perfect foresight you need a buffer stock in order to obtain equilibrium between demand and supply. \n- The role of buffer stocks in PK-SFC model is thus fundamental and is at the hart of the approach used by @Godley:1999c in his seven unsustainable processes. - It is by observing the dynamics of certain stock-flow norms that you are able to observe the unsustainable processes evolving in an economy, because stocks precisely absorb disequilibrium.\n\n## Sankey Diagrams\n\n```{r, eval=F}\nplot.sankey(as.data.frame(datapcRand$baseline),filename=\"TFM_PC.csv\",period=2)\n```\n\n```{r, echo=F}\nnumericInput(\"period\", \"Which period?\", 2)\nrenderSankeyNetwork({\n  test=plot.sankey(as.data.frame(datapcRand$baseline),filename=\"TFM_PC.csv\",period=input$period)\n  test\n})\n```\n\n## Shiny Apps\n\n```{r,echo=F,message=FALSE,eval=T}\nfluidPage(\n  \n  titlePanel(\"Model SIMEX\"),\n  \n  \n  mainPanel(\n    tabsetPanel(\n      tabPanel(\"Equations\", renderTable({\n        simex<-sfc.model(\"SIMEX.txt\",modelName=\"SIMplest model\")\n        temp<-as.data.frame(simex$equations[,c(1,2)])\n        colnames(temp)<-c(\"Variable\",\"Equation\")\n        temp\n        #matrix(c(getwd(),list.dirs(getwd())),ncol=1)\n      })),\n      tabPanel(\"DAG\",  renderPlot({\n        simex<-sfc.model(\"SIMEX.txt\",modelName=\"SIMplest model\")\n        plot.dag(simex,main=\"SIMEX\")\n      })),\n      tabPanel(\"Plot Scenarios\",fluidRow(\n        column(12,checkboxGroupInput(\"checkGroup\",\n                                     label = h4(\"Variables\"),\n                                     inline=T,\n                                     choices = list(\"Consumption\" = \"C\",\"Disposable Income\" = \"Yd\",\n                                                    \"Taxes\" = \"T\", \"Government Expenditure\" = \"G\",\n                                                    \"GDP\" = \"Y\", \"Expected disposable income\" = \"Yd_e\",\n                                                    \"Household wealth\" = \"H\"),\n                                     selected = c(\"Yd_e\",\"Yd\"))),\n        column(12, renderPlot({\n          simex<-sfc.model(\"SIMEX.txt\",modelName=\"SIMplest model\")\n          vars<-c()\n          values<-c()\n          if(input$alpha1!=as.numeric(simex$variables[9,2])){\n            vars<-c(vars,\"alpha1\")\n            values<-c(values,input$alpha1)\n          }\n          if(input$alpha2!=as.numeric(simex$variables[10,2])){\n            vars<-c(vars,\"alpha2\")\n            values<-c(values,input$alpha2)\n          }\n          if(input$theta!=as.numeric(simex$variables[11,2])){\n            vars<-c(vars,\"theta\")\n            values<-c(values,input$theta)\n          }\n          if(input$G!=as.numeric(simex$variables[12,2])){\n            vars<-c(vars,\"G\")\n            values<-c(values,input$G)\n          }\n          if(length(vars)>0){\n            simex<-sfc.addScenario(model=simex,vars=list(vars),values=list(values),inits=1975,ends=2010)\n            datasimex<-simulate(simex)\n            myData<-as.data.frame(datasimex$baseline)\n            myData1<-as.data.frame(datasimex$scenario_1)\n            #PLace 3, runs every time somtheing changes in the widgets\n            varnames<-input$checkGroup\n            matplot(rownames(myData),cbind(myData[c(varnames)],myData1[c(varnames)]),type=\"l\",xlab=\"\",ylab=\"\",lwd=2,lty=c(rep(1,length(varnames)),rep(2,length(varnames))),col=1:length(varnames))\n            legend(\"topleft\",col=1:length(varnames),bty='n',lwd=2,lty=c(rep(1,length(varnames)),rep(2,length(varnames))),legend=c(varnames,paste(varnames,\"_scen\",sep=\"\")))\n          }else{\n            datasimex<-simulate(simex)\n            myData<-as.data.frame(datasimex$baseline)\n            #PLace 3, runs every time somtheing changes in the widgets\n            varnames<-input$checkGroup\n            matplot(rownames(myData),myData[c(varnames)],type=\"l\",xlab=\"\",ylab=\"\",lwd=2,lty=1)\n            legend(\"topleft\",col=1:length(varnames),bty='n',lwd=2,lty=1,legend=varnames)\n          }\n          \n        })),\n        column(6,sliderInput(\"alpha1\",\n                             label = \"Propensity to consume out of income:\",\n                             min = 0, max = 1, value = 0.6),\n               \n               sliderInput(\"alpha2\",\n                           label = \"Propensity to consume out of wealth:\",\n                           min = 0, max = 1, value = 0.4)),\n        column(6,\n               sliderInput(\"theta\",\n                           label = \"Taxation out of income rate:\",\n                           min = 0, max = 1, value = 0.2),\n               sliderInput(\"G\",\n                           label = \"Government Expenditure\",\n                           min = 0, max = 100, value = 20)\n        )\n      )\n      )\n    )\n  )\n)\n\n```\n\n## Example of Shiny Apps\n\n[Model SIM](http://antoinegodin.shinyapps.io/SIMple)\n[Model SIMEX](http://antoinegodin.shinyapps.io/SIMEX)\n[Agent Based Version of SIM](http://antoinegodin.shinyapps.io/AB-SFC)\n[GitHub Repository](http://github.com/antoinegodin/ShinySFC)\n\n## References",
    "created" : 1469981509289.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1442937372",
    "id" : "C4501A85",
    "lastKnownWriteTime" : 1470180594,
    "last_content_update" : 1470180594576,
    "path" : "C:/Users/ku57637/Dropbox/Research/Seminars/AppliedSFC_R/Lecture1.Rmd",
    "project_path" : "Lecture1.Rmd",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}